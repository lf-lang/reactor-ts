// Code generated by the Lingua Franca compiler from file:
// https://github.com/icyphy/lingua-franca/blob/master/example/DistributedTS/Distributed.lf

import {Args, Parameter, State, Read, Triggers, ReadWrite, Action, Timer, Reactor,OutPort, InPort} from '../../../core/reactor'
import {FederatedApp} from '../../../core/federation'
import {TimeUnit, TimeValue, Tag, Origin} from '../../../core/time'

// ************* App Parameters
let __timeout: TimeValue | undefined = TimeValue.withUnits(10, TimeUnit.secs);
let __keepAlive: boolean = true;
let __fast: boolean = false;

let __noStart = false; // If set to true, don't start the app.

// Custom command line arguments

// Assign custom command line arguments
// =============== START reactor class PrintMessage
export class PrintMessage extends Reactor {
    message: InPort<string>;
    constructor (
        parent: Reactor
    ) {
        super(parent);
        this.message = new InPort<string>(this);
        this.addReaction(
            new Triggers(this.message),
            new Args(this.message),
            function (this, __message: Read<string>) {
                // =============== START react prologue
                const util = this.util;
                let message = __message.get();
                // =============== END react prologue
                try {
                    console.log(`PrintMessage: At (elapsed) logical time ${util.getElapsedLogicalTime()}, receiver receives: ${message}`);
                } finally {
                    // =============== START react epilogue
                    
                    // =============== END react epilogue
                }
            }
        );
    }
}
// =============== END reactor class PrintMessage

// =============== START reactor class Distributed
export class Distributed extends FederatedApp {
    dsp: PrintMessage
    networkMessage: Action<Buffer>;
    constructor (
        timeout: TimeValue | undefined = undefined, 
        keepAlive: boolean = false, 
        fast: boolean = false, 
        success?: () => void, 
        fail?: () => void
    ) {
        super(1, 15045, "localhost", timeout, keepAlive, fast, success, fail);
        this.addUpstreamFederate(0, BigInt(0));
        this.dsp = new PrintMessage(this)
        this.networkMessage = new Action<Buffer>(this, Origin.logical, TimeValue.withUnits(10, TimeUnit.msec));
        this.registerFederatePortAction(0, this.networkMessage);
        this.addReaction(
            new Triggers(this.networkMessage),
            new Args(this.networkMessage, this.writable(this.dsp.message)),
            function (this, __networkMessage: Read<Buffer>, __dsp_message: ReadWrite<string>) {
                // =============== START react prologue
                const util = this.util;
                let networkMessage = __networkMessage.get();
                let dsp = {message: __dsp_message.get()}
                // =============== END react prologue
                try {
                    // FIXME: For now assume the data is a string, but this is not checked.
                    // Replace with ProtoBufs or MessagePack.
                    if (networkMessage !== undefined) {
                        dsp.message = networkMessage.toString(); // defaults to utf8 encoding
                    }
                } finally {
                    // =============== START react epilogue
                    if (dsp.message !== undefined) {
                        __dsp_message.set(dsp.message)
                    }
                    // =============== END react epilogue
                }
            }
        );
    }
}
// =============== END reactor class Distributed

// ************* Instance Distributed of class Distributed
let __app;
if (!__noStart) {
    __app = new Distributed(__timeout, __keepAlive, __fast, );
}
// ************* Starting Runtime for Distributed + of class Distributed.
if (!__noStart && __app) {
    __app._start();
}
